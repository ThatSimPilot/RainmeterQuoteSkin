<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description"
        content="Generate custom quotes for your Rainmeter skin with fonts, colors, and alignments.">
    <meta name="author" content="ThatSimPilot">
    <title>Rainmeter Quote Skin Generator - ThatSimPilot</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <div class="col-6 p-3">
                <!-- Column 1 -->
                <h1 class="display-4">Edit Quote</h1>
                <form>
                    <div class="mb-3">
                        <label for="quote" class="form-label">Quote:</label>
                        <textarea rows="3" class="form-control" id="quote" name="quote"
                            style="resize: both; max-width: 100%; min-width: 100%;"></textarea>
                        <div class="input-group">
                            <span class="input-group-text" id="quoteAlignment">Quote Alignment</span>
                            <select class="form-control" id="quoteAlignmentSelect" name="quoteAlignmentSelect">
                                <option value="left" selected>Left</option>
                                <option value="center">Center</option>
                                <option value="right">Right</option>
                                <option value="justify">Justify</option>
                            </select>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="byLine" class="form-label">By-Line:</label>
                        <input type="text" class="form-control" id="byLine" name="byLine">
                        <div class="input-group">
                            <span class="input-group-text" id="byLineAlignment">By-Line Alignment</span>
                            <select class="form-control" id="byLineAlignmentSelect" name="byLineAlignmentSelect">
                                <option value="left" selected>Left</option>
                                <option value="center">Center</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="font" class="form-label">Font:</label>
                        <div class="input-group">
                            <select class="form-control" id="fontSource" name="fontSource" disabled>
                                <option value="system">Windows Fonts</option>
                                <option value="google" disabled>Google Fonts</option>
                            </select>
                            <select class="form-control" id="fontName" name="fontName">
                                <optgroup label="Sans-serif"></optgroup>
                                <option value="Segoe UI">Segoe UI</option>
                                <option value="Segoe UI Semibold">Segoe UI Semibold</option>
                                <option value="Calibri">Calibri</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Arial">Arial</option>
                                </optgroup>

                                <optgroup label="Serif">
                                    <option value="Georgia">Georgia</option>
                                    <option value="Palatino Linotype">Palatino Linotype</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                </optgroup>

                                <optgroup label="Cursive">
                                    <option value="Segoe Script" selected>Segoe Script (Default)</option>
                                    <option value="Segoe Print">Segoe Print</option>
                                    <option value="Lucida Handwriting">Lucida Handwriting</option>
                                </optgroup>

                                <optgroup label="Monospace">
                                    <option value="Consolas">Consolas</option>
                                </optgroup>

                                <optgroup label="Custom">
                                    <option value="">Custom font name…</option>
                                </optgroup>
                            </select>
                        </div>
                        <div id="fontHelp" class="form-text">Fonts must be installed on your device</div>
                    </div>
                    <div class="mb-3">
                        <label for="fontColour" class="form-label">Font Colour:</label>
                        <div class="input-group">
                            <span class="input-group-text" id="colourHex">Hex: #ffffff</span>
                            <input type="color" class="form-control form-control-color" id="fontColour"
                                name="fontColour" value="#ffffff" title="Choose your color">
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="maxWidth" class="form-label">Max Characters per Line: <span
                                id="maxWidthValue">75</span></label>
                        <input type="range" class="form-range" id="maxWidth" name="maxWidth" value="75" min="25"
                            max="150" step="5">
                        <div class="form-text">Adjusts the estimated maximum characters per line for text wrapping in
                            the preview.</div>
                    </div>
                    <button type="submit" class="btn btn-primary" id="submitQuoteBtn">Add to Package</button>
                </form>
            </div>
            <div class="col-6 p-3">
                <!-- PREVIEW Content Here -->
                <h1 class="display-4">Preview</h1>
                <div class="mb-3 form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="previewDarkMode" checked>
                    <label class="form-check-label" for="previewDarkMode">Dark preview</label>
                </div>
                <div class="mb-3">
                    <label for="previewRendered" class="form-label">Rendered Preview:</label>
                    <div id="previewRendered" class="p-3 border rounded" style="min-height:120px;">
                        <div class="d-flex justify-content-center align-items-center h-100">
                            <div id="previewContent" style="width:100%;">
                                <div id="previewQuote" style="font-size:1.25rem;"></div>
                                <div id="previewByline" style="margin-top:0.75rem; opacity:0.9"></div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        <div class="row">
            <div class="col-12 p-3">
                <!-- Generated -->
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h1 class="display-6 mb-0">Generated Package</h1>
                    <div>
                        <input type="file" id="uploadPackageInput" accept=".json,.lua" style="display:none">
                        <button id="uploadPackageBtn" class="btn btn-secondary">Upload Existing Package</button>
                    </div>
                </div>
                <table class="table">
                    <thead>
                        <tr>
                            <th scope="col">Quote</th>
                            <th scope="col">By-Line</th>
                            <th scope="col">Font</th>
                            <th scope="col">Colour</th>
                            <th scope="col">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="packageTbody">

                    </tbody>
                </table>
                <div class="d-flex gap-2 mb-3">
                    <div class="btn-group">
                        <button type="button" class="btn btn-success" id="downloadPackageBtn">Download Package</button>
                        <button type="button" class="btn btn-success dropdown-toggle dropdown-toggle-split"
                            data-bs-toggle="dropdown" aria-expanded="false">
                            <span class="visually-hidden">Toggle Dropdown</span>
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" id="downloadLua">Download quotes.lua</a></li>
                            <li><a class="dropdown-item" href="#" id="downloadIni">Download quotes.ini</a></li>
                        </ul>
                    </div>
                    <button id="clearPackage" class="btn btn-outline-danger" type="button">Clear Package</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Modal -->
    <div class="modal fade" id="downloadModal" tabindex="-1" aria-labelledby="downloadModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="downloadModalLabel">Download Complete</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Your Rainmeter Quote Skin package has been downloaded as <code>RainmeterQuoteSkin.zip</code>.</p>
                    <p><strong>If Windows Defender or your antivirus blocked the extraction:</strong></p>
                    <ol>
                        <li>Locate the downloaded ZIP file in your Downloads folder.</li>
                        <li>Right-click the file and select "Properties".</li>
                        <li>On the General tab, check the "Unblock" box at the bottom.</li>
                        <li>Click "Apply" then "OK".</li>
                        <li>Try extracting the ZIP file again.</li>
                        <br>
                        <li>Alternatively, extract the ZIP file manually using a third-party tool like 7-Zip or WinRAR.
                        </li>
                    </ol>
                    <p>After extraction, copy the folder containing <code>quotes.ini</code> and <code>quotes.lua</code>
                        to your Rainmeter Skins folder (or create a new folder for them).</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        const STORAGE_KEY = "rm_quote_package_v1";

        const INI_CONTENT = `[Rainmeter]
Update=1000
AccurateText=1
OnRefreshAction=[!CommandMeasure MeasureQuotes "GetQuote()"]

[Variables]
FontName=Segoe UI
DefaultSize=18
DefaultColor=255,255,255
AuthorColor=180,180,180

[MeasureQuotes]
Measure=Script
ScriptFile=#@#Scripts\\quotes.lua

[MeterQuote]
Meter=String
Text=#QuoteText#
DynamicVariables=1
FontFace=#QuoteFont#
FontSize=#QuoteSize#
FontColor=#QuoteColor#
StringAlign=#QuoteAlign#
AntiAlias=1
W=400
H=200
ClipString=2
X=20
Y=20

[MeterAuthor]
Meter=String
Text=- #QuoteAuthor#
DynamicVariables=1
FontFace=#QuoteFont#
FontSize=14
FontColor=#QuoteColor#
StringAlign=#QuoteByAlign#
AntiAlias=1
X=20
Y=([MeterQuote:Y] + [MeterQuote:H] + 10)`;

        const README_CONTENT = `# Rainmeter Quote Skin

This is a Rainmeter skin that displays inspirational quotes. The quotes are stored in \`quotes.lua\` and updated daily.

## Installation

1. Copy the folder 'RainmeterQuoteSkin' to your Rainmeter Skins folder or create a folder and copy \`quotes.ini\` and \`quotes.lua\` to this.
2. Load the skin in Rainmeter.

## Customization

Visit https://thatsimpilot.github.io/RainmeterQuoteSkin/ and upload quotes.lua file to modify existing or add new quotes to the package.

Alternatively, for ADVANCED USERS ONLY: Manually edit \`quotes.lua\` to add or modify quotes. Each quote has text, author, font, color, and alignment options.

## Generated by

Rainmeter Quote Skin Generator
©ThatSimPilot (Hayden H)`;

        const colourInput = document.getElementById("fontColour");
        const colourHex = document.getElementById("colourHex");
        const quoteInput = document.getElementById("quote");
        const byLineInput = document.getElementById("byLine");
        const fontSelect = document.getElementById("fontName");
        const maxWidthInput = document.getElementById("maxWidth");
        const maxWidthValue = document.getElementById("maxWidthValue");

        const previewQuote = document.getElementById("previewQuote");
        const previewByline = document.getElementById("previewByline");
        const previewRendered = document.getElementById("previewRendered");
        const previewContent = document.getElementById("previewContent");
        const quoteAlignSelect = document.getElementById("quoteAlignmentSelect");
        const byLineAlignSelect = document.getElementById("byLineAlignmentSelect");
        const darkToggle = document.getElementById("previewDarkMode");

        const form = document.querySelector("form");
        const packageTbody = document.getElementById("packageTbody");
        const downloadLuaBtn = document.getElementById("downloadLua");
        const clearPackageBtn = document.getElementById("clearPackage");
        const uploadPackageBtn = document.getElementById("uploadPackageBtn");
        const uploadPackageInput = document.getElementById("uploadPackageInput");

        // ---------- Helpers ----------
        function escapeHtml(s) {
            return String(s)
                .replaceAll("&", "&amp;")
                .replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;")
                .replaceAll('"', "&quot;")
                .replaceAll("'", "&#39;");
        }

        function escapeLuaString(s) {
            return String(s)
                .replaceAll("\\", "\\\\")
                .replaceAll("\r\n", "\n")
                .replaceAll("\r", "\n")
                .replaceAll("\n", "\\n")
                .replaceAll('"', '\\"');
        }

        function hexToRgb(hex) {
            // expects #RRGGBB
            const h = (hex || "#000000").replace("#", "");
            const r = parseInt(h.slice(0, 2), 16);
            const g = parseInt(h.slice(2, 4), 16);
            const b = parseInt(h.slice(4, 6), 16);
            return { r, g, b };
        }

        function downloadText(filename, text) {
            const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function normalizeForRainmeter(s) {
            return String(s)
                .replaceAll("’", "'")
                .replaceAll("‘", "'")
                .replaceAll("“", '"')
                .replaceAll("”", '"')
                .replaceAll("…", "...")
                .replaceAll("–", "-")
                .replaceAll("—", "-");
        }

        function getFontFamilyValue() {
            const val = (fontSelect && fontSelect.value) ? fontSelect.value : "";
            // If they chose "Custom font name…" (value=""), fall back to Segoe UI for now.
            // Later you can add a custom font input if you want.
            return val || "Segoe UI";
        }

        function getCurrentFormData() {
            const quote = (quoteInput.value || "").trim();
            const byline = (byLineInput.value || "").trim();
            const colour = (colourInput && colourInput.value) ? colourInput.value : "#000000";
            const fontFamily = getFontFamilyValue();

            return {
                quote,
                byline,
                fontFamily,
                colourHex: colour.toUpperCase(),
                quoteAlign: (quoteAlignSelect && quoteAlignSelect.value) ? quoteAlignSelect.value : "left",
                bylineAlign: (byLineAlignSelect && byLineAlignSelect.value) ? byLineAlignSelect.value : "right",
                createdAt: Date.now()
            };
        }

        // ---------- Package state ----------
        function loadPackage() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
            } catch {
                return [];
            }
        }

        function savePackage(items) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
        }

        let packageItems = loadPackage();
        let editIndex = null;
        let luaFileHandle = null;

        // ---------- Preview ----------
        function updatePreview() {
            const data = getCurrentFormData();

            previewQuote.textContent = data.quote ? `"${data.quote}"` : "";
            previewByline.textContent = data.byline ? `— ${data.byline}` : "";

            previewQuote.style.whiteSpace = "pre-wrap";
            previewByline.style.whiteSpace = "pre-wrap";

            previewRendered.style.color = data.colourHex;
            previewRendered.style.fontFamily = data.fontFamily;

            previewQuote.style.textAlign = data.quoteAlign;
            previewByline.style.textAlign = data.bylineAlign;

            const dark = darkToggle && darkToggle.checked;
            previewRendered.style.backgroundColor = dark ? "#111" : "#fff";
            previewRendered.style.borderColor = dark ? "#444" : "#dee2e6";

            // Update max width based on character count
            if (previewContent && maxWidthInput) {
                const charWidth = 8; // approximate pixels per character
                previewContent.style.maxWidth = (maxWidthInput.value * charWidth) + 'px';
            }
        }

        // ---------- Table render ----------
        function renderPackageTable() {
            if (!packageTbody) return;

            packageTbody.innerHTML = packageItems.map((item, idx) => {
                const fontPreview = `style="font-family:${escapeHtml(item.fontFamily)}"`;
                const colorSwatch = `<span class="badge" style="background:${item.colourHex}; border:1px solid rgba(0,0,0,0.2)">${item.colourHex}</span>`;

                return `
        <tr>
          <td>${escapeHtml(item.quote)}</td>
          <td>${escapeHtml(item.byline)}</td>
          <td ${fontPreview}>${escapeHtml(item.fontFamily)}</td>
          <td>${colorSwatch}</td>
          <td class="text-end text-nowrap">
  <button class="btn btn-sm btn-outline-secondary me-1" data-edit="${idx}">
    Edit
  </button>
  <button class="btn btn-sm btn-outline-danger" data-del="${idx}">
    Delete
  </button>
</td>
        </tr>
      `;
            }).join("");

            // Delete handlers
            packageTbody.querySelectorAll("[data-del]").forEach(btn => {
                btn.addEventListener("click", () => {
                    const i = Number(btn.getAttribute("data-del"));
                    packageItems.splice(i, 1);
                    savePackage(packageItems);
                    renderPackageTable();
                });
            });
            // Edit handlers
            packageTbody.querySelectorAll("[data-edit]").forEach(btn => {
                btn.addEventListener("click", () => {
                    const i = Number(btn.getAttribute("data-edit"));
                    loadItemIntoForm(i);
                });
            });
        }

        // ---------- Load item into form for editing ----------
        function loadItemIntoForm(index) {
            const item = packageItems[index];
            if (!item) return;

            editIndex = index;

            // Populate form fields
            quoteInput.value = item.quote;
            byLineInput.value = item.byline;
            fontSelect.value = item.fontFamily || "Segoe UI";
            colourInput.value = item.colourHex || "#ffffff";
            quoteAlignSelect.value = item.quoteAlign || "left";
            byLineAlignSelect.value = item.bylineAlign || "right";

            // Update UI bits
            if (colourHex) colourHex.textContent = `Hex: ${item.colourHex}`;
            document.getElementById("submitQuoteBtn").textContent = "Save Changes";

            updatePreview();
        }


        // ---------- Lua export ----------
        function generateQuotesLua(items) {
            console.log("generateQuotesLua called with", items.length, "items");

            const lines = [];
            lines.push("-- quotes.lua");
            lines.push("-- Auto-generated by Rainmeter Quote Skin Generator");
            lines.push("-- Expected by your quotes.ini:");
            lines.push("--   [MeasureQuotes]");
            lines.push("--   Measure=Script");
            lines.push("--   ScriptFile=#@#Scripts\\quotes.lua");
            lines.push("");

            lines.push("quotes = {");
            for (const it of items) {
                const rgb = hexToRgb(it.colourHex);
                lines.push(
                    `  { text="${escapeLuaString(normalizeForRainmeter(it.quote))}", by="${escapeLuaString(normalizeForRainmeter(it.byline))}", font="${escapeLuaString(it.fontFamily)}", color={${rgb.r},${rgb.g},${rgb.b}}, align="${escapeLuaString(it.quoteAlign)}", byAlign="${escapeLuaString(it.bylineAlign)}" },`
                );
            }
            lines.push("}");
            lines.push("");

            lines.push(`
                local function clampAlign(a)
                if a == "left" or a == "center" or a == "right" or a == "justify" then return a end
                return "left"
                end

                local function clampByAlign(a)
                if a == "left" or a == "center" or a == "right" then return a end
                return "right"
                end

                local function safeColor(c)
                if type(c) == "table" and tonumber(c[1]) and tonumber(c[2]) and tonumber(c[3]) then
                    local r = math.floor(tonumber(c[1]) or 255)
                    local g = math.floor(tonumber(c[2]) or 255)
                    local b = math.floor(tonumber(c[3]) or 255)
                    if r < 0 then r = 0 elseif r > 255 then r = 255 end
                    if g < 0 then g = 0 elseif g > 255 then g = 255 end
                    if b < 0 then b = 0 elseif b > 255 then b = 255 end
                    return r, g, b
                end
                return 255, 255, 255
                end

                local function chooseQuoteIndex()
                local n = #quotes
                if n <= 0 then return nil end
                local day = tonumber(os.date("%j")) or 1
                local idx = (day % n) + 1
                return idx
                end

                function Initialize()
                end

                function GetQuote()
                if type(quotes) ~= "table" or #quotes == 0 then
                    SKIN:Bang("!SetVariable", "QuoteText", "No quotes found.")
                    SKIN:Bang("!SetVariable", "QuoteAuthor", "")
                    SKIN:Bang("!SetVariable", "QuoteFont", "Segoe UI")
                    SKIN:Bang("!SetVariable", "QuoteColor", "255,255,255")
                    SKIN:Bang("!SetVariable", "QuoteSize", "18")
                    SKIN:Bang("!SetVariable", "QuoteAlign", "left")
                    SKIN:Bang("!SetVariable", "QuoteByAlign", "right")
                else
                    local idx = chooseQuoteIndex()
                    local q = quotes[idx] or quotes[1]

                    local text = q.text or ""
                    local by = q.by or ""
                    local font = q.font or "Segoe UI"
                    local r, g, b = safeColor(q.color)
                    local align = clampAlign(q.align)
                    local byAlign = clampByAlign(q.byAlign)

                    SKIN:Bang("!SetVariable", "QuoteText", text)
                    SKIN:Bang("!SetVariable", "QuoteAuthor", by)
                    SKIN:Bang("!SetVariable", "QuoteFont", font)
                    SKIN:Bang("!SetVariable", "QuoteColor", string.format("%d,%d,%d", r, g, b))
                    SKIN:Bang("!SetVariable", "QuoteSize", "18")
                    SKIN:Bang("!SetVariable", "QuoteAlign", align)
                    SKIN:Bang("!SetVariable", "QuoteByAlign", byAlign)
                end

                SKIN:Bang("!UpdateMeter", "MeterQuote")
                SKIN:Bang("!UpdateMeter", "MeterAuthor")
                SKIN:Bang("!Redraw")
                end

                function Update()
                return 0
                end
                `.trim());

            // ✅ IMPORTANT: return the final Lua file text
            return lines.join("\n");
        }


        // ---------- Wire up ----------
        if (form) {
            form.addEventListener("submit", (e) => {
                e.preventDefault();

                const data = getCurrentFormData();
                if (!data.quote) return;

                if (editIndex === null) {
                    // ADD NEW
                    packageItems.push(data);
                } else {
                    // EDIT EXISTING
                    packageItems[editIndex] = data;
                    editIndex = null;
                    document.getElementById("submitQuoteBtn").textContent = "Add to Package";
                }

                savePackage(packageItems);
                renderPackageTable();

                // Clear quote fields after save
                quoteInput.value = "";
                byLineInput.value = "";
                updatePreview();
            });
        }

        const downloadPackageBtn = document.getElementById("downloadPackageBtn");

        if (downloadLuaBtn) {
            downloadLuaBtn.addEventListener("click", (e) => {
                e.preventDefault(); // stops the # jump

                if (!packageItems.length) {
                    alert("No quotes in the package yet.");
                    return;
                }

                const lua = generateQuotesLua(packageItems);
                downloadText("quotes.lua", lua);
            });
        }

        const downloadIniBtn = document.getElementById("downloadIni");
        if (downloadIniBtn) {
            downloadIniBtn.addEventListener("click", (e) => {
                e.preventDefault();
                downloadText("quotes.ini", INI_CONTENT);
            });
        }

        if (downloadPackageBtn) {
            downloadPackageBtn.addEventListener("click", async (e) => {
                e.preventDefault();
                console.log("Download Package clicked");

                if (!packageItems.length) {
                    alert("No quotes in the package yet.");
                    return;
                }

                try {
                    if (typeof JSZip === 'undefined') {
                        throw new Error("JSZip library not loaded. Please check your internet connection.");
                    }
                    // Update the lua file first
                    if (luaFileHandle) {
                        await updateLuaFile(packageItems);
                    }

                    // Generate ZIP
                    const zip = new JSZip();
                    const lua = generateQuotesLua(packageItems);

                    const root = zip.folder("RainmeterQuoteSkin");

                    root.file("quotes.ini", INI_CONTENT);

                    root
                        .folder("@Resources")
                        .folder("Scripts")
                        .file("quotes.lua", lua);

                    root.file("README.txt", README_CONTENT);

                    console.log("Lua length:", lua?.length, "first 100:", lua?.slice(0, 100));
                    const zipBlob = await zip.generateAsync({
                        type: "blob",
                        compression: "DEFLATE",
                        compressionOptions: { level: 6 }
                    });
                    const url = URL.createObjectURL(zipBlob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = "RainmeterQuoteSkin.zip";
                    a.click();
                    URL.revokeObjectURL(url);

                    // Show modal with instructions
                    const modal = new bootstrap.Modal(document.getElementById('downloadModal'));
                    modal.show();
                } catch (error) {
                    console.error("Error generating ZIP:", error);
                    alert("Error generating package: " + error.message);
                }
            });
        }



        if (clearPackageBtn) {
            clearPackageBtn.addEventListener("click", () => {
                packageItems = [];
                editIndex = null;
                savePackage(packageItems);
                renderPackageTable();
                document.getElementById("submitQuoteBtn").textContent = "Add to Package";
            });
        }

        // Live preview listeners
        if (quoteInput) quoteInput.addEventListener("input", updatePreview);
        if (byLineInput) byLineInput.addEventListener("input", updatePreview);
        if (fontSelect) fontSelect.addEventListener("change", updatePreview);
        if (quoteAlignSelect) quoteAlignSelect.addEventListener("change", updatePreview);
        if (byLineAlignSelect) byLineAlignSelect.addEventListener("change", updatePreview);
        if (darkToggle) darkToggle.addEventListener("change", updatePreview);
        if (colourInput) {
            colourInput.addEventListener("input", () => {
                if (colourHex) colourHex.textContent = `Hex: ${colourInput.value.toUpperCase()}`;
                updatePreview();
            });
        }
        if (maxWidthInput) maxWidthInput.addEventListener("input", () => {
            if (maxWidthValue) maxWidthValue.textContent = maxWidthInput.value;
            updatePreview();
        });

        // Wire upload button to hidden file input
        function rgbToHex(r, g, b) {
            const toHex = (n) => n.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
        }

        function tryParseLuaQuotes(luaText) {
            // Very small parser: find table entries inside quotes = { ... }
            const entries = [];
            const blockRegex = /\{([\s\S]*?)\},?/g;
            let m;
            while ((m = blockRegex.exec(luaText)) !== null) {
                const block = m[1];
                const getString = (key) => {
                    const re = new RegExp(key + '\\s*=\\s*"([\\s\\S]*?)"', 'i');
                    const mm = block.match(re);
                    if (!mm) return '';
                    return mm[1].replace(/\\\\n/g, '\n').replace(/\\\\"/g, '"').replace(/\\\\\\\\/g, '\\');
                };
                const text = getString('text');
                const by = getString('by');
                const font = getString('font') || 'Segoe UI';
                const alignMatch = block.match(/align\\s*=\\s*"(.*?)"/i);
                const byAlignMatch = block.match(/byAlign\\s*=\\s*"(.*?)"/i);
                const colorMatch = block.match(/color\s*=\s*\{\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\}/i);
                const rgb = colorMatch ? { r: Number(colorMatch[1]), g: Number(colorMatch[2]), b: Number(colorMatch[3]) } : { r: 0, g: 0, b: 0 };
                const colourHex = rgbToHex(rgb.r, rgb.g, rgb.b);

                // require at least text
                if (text) {
                    entries.push({
                        quote: text,
                        byline: by,
                        fontFamily: font,
                        colourHex,
                        quoteAlign: (alignMatch && alignMatch[1]) ? alignMatch[1] : 'left',
                        bylineAlign: (byAlignMatch && byAlignMatch[1]) ? byAlignMatch[1] : 'right',
                        createdAt: Date.now()
                    });
                }
            }
            return entries;
        }

        function importPackageFromJson(text) {
            const parsed = JSON.parse(text);
            if (!Array.isArray(parsed)) throw new Error('JSON must be an array of package items');
            // Map/validate entries
            return parsed.map(it => ({
                quote: String(it.quote || it.text || '').trim(),
                byline: String(it.byline || it.by || '').trim(),
                fontFamily: String(it.fontFamily || it.font || 'Segoe UI'),
                colourHex: String(it.colourHex || it.color || '#000000').toUpperCase(),
                quoteAlign: String(it.quoteAlign || it.align || 'left'),
                bylineAlign: String(it.bylineAlign || it.byAlign || 'right'),
                createdAt: it.createdAt || Date.now()
            }));
        }

        if (uploadPackageBtn && uploadPackageInput) {
            uploadPackageBtn.addEventListener('click', () => uploadPackageInput.click());
            uploadPackageInput.addEventListener('change', (e) => {
                const f = e.target.files && e.target.files[0];
                if (!f) return;
                const name = f.name || '';
                const reader = new FileReader();
                reader.onerror = () => alert('Failed to read file');
                reader.onload = () => {
                    const txt = String(reader.result || '');
                    try {
                        let imported = [];
                        if (/\.json$/i.test(name)) {
                            imported = importPackageFromJson(txt);
                        } else if (/\.lua$/i.test(name)) {
                            imported = tryParseLuaQuotes(txt);
                        } else if (/\.zip$/i.test(name)) {
                            alert('ZIP import not supported yet.');
                            return;
                        } else {
                            // try JSON first, then Lua
                            try { imported = importPackageFromJson(txt); }
                            catch (e) { imported = tryParseLuaQuotes(txt); }
                        }

                        if (!imported || imported.length === 0) {
                            alert('No valid entries were found in the selected file.');
                            return;
                        }

                        // Merge into existing packageItems
                        packageItems = packageItems.concat(imported);
                        savePackage(packageItems);
                        renderPackageTable();
                        alert(`Imported ${imported.length} item(s).`);
                    } catch (err) {
                        console.error(err);
                        alert('Failed to import package: ' + err.message);
                    }
                };
                reader.readAsText(f);
                // clear selection so same file can be re-selected later
                uploadPackageInput.value = '';
            });
        }

        // Initial UI sync
        if (colourHex && colourInput) colourHex.textContent = `Hex: ${colourInput.value.toUpperCase()}`;
        if (maxWidthValue && maxWidthInput) maxWidthValue.textContent = maxWidthInput.value;
        updatePreview();
        renderPackageTable();
    </script>
</body>

</html>