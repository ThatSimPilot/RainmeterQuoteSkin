"use strict";

const LUA_HEADER = `
-- quotes.lua
-- Auto-generated by Rainmeter Quote Skin Generator
-- Expected by your quotes.ini:
--   [MeasureQuotes]
--   Measure=Script
--   ScriptFile=#@#Scripts\\quotes.lua
`.trim();

const LUA_RUNTIME_TEMPLATE = `
local function safeNumber(v, fallback)
  local n = tonumber(v)
  if n == nil then return fallback end
  return n
end

local function safeColor(c)
  if type(c) == "table" then
    local r = math.floor(safeNumber(c[1], 255))
    local g = math.floor(safeNumber(c[2], 255))
    local b = math.floor(safeNumber(c[3], 255))
    if r < 0 then r = 0 elseif r > 255 then r = 255 end
    if g < 0 then g = 0 elseif g > 255 then g = 255 end
    if b < 0 then b = 0 elseif b > 255 then b = 255 end
    return r, g, b
  end
  return 255, 255, 255
end

local function toTopAlign(a, default)
  a = (a or default or "left"):lower()
  if a == "center" then return "CenterTop" end
  if a == "right" then return "RightTop" end
  return "LeftTop"
end

local function computeX(alignTop, baseX, width)
  if alignTop == "RightTop" then return baseX + width end
  if alignTop == "CenterTop" then return baseX + (width / 2) end
  return baseX
end

local function nQuotes()
  return (type(quotes) == "table") and #quotes or 0
end

local function positionAuthorBelowQuote()
  local quoteY = safeNumber(SKIN:GetVariable("QuoteY"), 20)
  local gap = safeNumber(SKIN:GetVariable("Gap"), 12)

  -- Ensure quote meter is rendered so height is accurate
  SKIN:Bang("!UpdateMeter", "MeterQuote")
  SKIN:Bang("!Redraw")

  local quoteMeter = SKIN:GetMeter("MeterQuote")
  local quoteHeight = 0
  if quoteMeter ~= nil then
    quoteHeight = quoteMeter:GetH()
  end

  local authorY = quoteY + quoteHeight + gap
  SKIN:Bang("!SetOption", "MeterAuthor", "Y", tostring(authorY))
end

local function persist(key, value)
  SKIN:Bang("!WriteKeyValue", "Variables", key, tostring(value), "#@#State.inc")
  SKIN:Bang("!SetVariable", key, tostring(value))
end

-- Simple deterministic hash for a string (date) -> integer
local function hashString(s)
  local h = 5381
  for i = 1, #s do
    h = ((h * 33) + string.byte(s, i)) % 2147483647
  end
  return h
end

local function isLikelyRefresh()
  local lastUnload = safeNumber(SKIN:GetVariable("LastUnload"), 0)
  local now = os.time()
  local delta = now - lastUnload
  -- If we unloaded and reloaded within ~3 seconds, it was a skin refresh.
  return (lastUnload > 0 and delta >= 0 and delta <= 3)
end

local function ensureDailyBaseIndex()
  local n = nQuotes()
  if n <= 0 then return 0 end

  local today = os.date("%Y-%m-%d")
  local storedDay = tostring(SKIN:GetVariable("DayStamp") or "")
  local lastBase = safeNumber(SKIN:GetVariable("LastDailyBaseIndex"), 0)

  if storedDay ~= today then
    math.randomseed(hashString(today))
    local idx = math.random(1, n)

    if n > 1 and idx == lastBase then
      idx = (idx % n) + 1
    end

    persist("DayStamp", today)
    persist("LastDailyBaseIndex", idx)
    persist("DailyBaseIndex", idx)
    persist("CurrentIndex", idx)
    return idx
  end

  local base = safeNumber(SKIN:GetVariable("DailyBaseIndex"), 0)
  if base < 1 or base > n then
    base = 1
    persist("DailyBaseIndex", base)
    persist("CurrentIndex", base)
  end

  return base
end

local function applyQuote(idx)
  local baseX = safeNumber(SKIN:GetVariable("QuoteX"), 20)
  local width = safeNumber(SKIN:GetVariable("QuoteW"), 520)

  if idx <= 0 or nQuotes() <= 0 then
    SKIN:Bang("!SetVariable", "QuoteText", "No quotes found.")
    SKIN:Bang("!SetVariable", "QuoteAuthor", "")
    SKIN:Bang("!SetVariable", "QuoteFont", SKIN:GetVariable("DefaultFont") or "Segoe Quote")
    SKIN:Bang("!SetVariable", "QuoteSize", SKIN:GetVariable("DefaultSize") or "18")
    SKIN:Bang("!SetVariable", "QuoteColor", SKIN:GetVariable("DefaultColor") or "255,255,255")
    SKIN:Bang("!SetVariable", "QuoteAlign", "LeftTop")
    SKIN:Bang("!SetVariable", "QuoteByAlign", "LeftTop")
    SKIN:Bang("!SetVariable", "QuoteXPos", tostring(baseX))
    SKIN:Bang("!SetVariable", "ByXPos", tostring(baseX))

    positionAuthorBelowQuote()
    SKIN:Bang("!UpdateMeter", "MeterQuote")
    SKIN:Bang("!UpdateMeter", "MeterAuthor")
    SKIN:Bang("!Redraw")
    return
  end

  local q = quotes[idx] or quotes[1]
  local text = q.text or ""
  local by = q.by or ""
  local font = q.font or (SKIN:GetVariable("DefaultFont") or "Segoe Quote")
  local r, g, b = safeColor(q.color)

  local quoteAlignTop = toTopAlign(q.align, "left")
  local byAlignTop = toTopAlign(q.byAlign, "left")

  local quoteXPos = computeX(quoteAlignTop, baseX, width)
  local byXPos = computeX(byAlignTop, baseX, width)

  SKIN:Bang("!SetVariable", "QuoteText", text)
  SKIN:Bang("!SetVariable", "QuoteAuthor", by)
  SKIN:Bang("!SetVariable", "QuoteFont", font)
  SKIN:Bang("!SetVariable", "QuoteSize", SKIN:GetVariable("DefaultSize") or "18")
  SKIN:Bang("!SetVariable", "QuoteColor", string.format("%d,%d,%d", r, g, b))
  SKIN:Bang("!SetVariable", "QuoteAlign", quoteAlignTop)
  SKIN:Bang("!SetVariable", "QuoteByAlign", byAlignTop)
  SKIN:Bang("!SetVariable", "QuoteXPos", tostring(quoteXPos))
  SKIN:Bang("!SetVariable", "ByXPos", tostring(byXPos))

  positionAuthorBelowQuote()

  SKIN:Bang("!UpdateMeter", "MeterQuote")
  SKIN:Bang("!UpdateMeter", "MeterAuthor")
  SKIN:Bang("!Redraw")
end

local function seedForSession()
  -- seed randomness per session/load
  local s = os.time()
  local lu = safeNumber(SKIN:GetVariable("LastUnload"), 0)
  math.randomseed(s + (lu % 100000))
  -- throw away first few values (Lua RNG quirk)
  math.random(); math.random(); math.random()
end

local function randomDifferent(n, exclude)
  if n <= 1 then return 1 end
  local idx = exclude
  local guard = 0
  while idx == exclude and guard < 20 do
    idx = math.random(1, n)
    guard = guard + 1
  end
  if idx == exclude then
    idx = (exclude % n) + 1
  end
  return idx
end

function Initialize()
  local n = nQuotes()
  if n <= 0 then
    applyQuote(0)
    return
  end

  local cycle = safeNumber(SKIN:GetVariable("CycleOnRefresh"), 1)

  -- Ensure daily base is correct (and updated if the date changed)
  local base = ensureDailyBaseIndex()

  -- Default to base unless we are cycling on load
  local cur = safeNumber(SKIN:GetVariable("CurrentIndex"), base)

  if cycle == 1 then
    seedForSession()
    cur = randomDifferent(n, cur)
    persist("CurrentIndex", cur)
  else
    -- no cycling: stick to daily base/current
    persist("CurrentIndex", cur)
  end

  applyQuote(cur)
end

local lastMidnightCheck = 0

function Update()
  -- Only check once per minute (even if skin Update=1000)
  local now = os.time()
  if now - lastMidnightCheck < 60 then
    return 0
  end
  lastMidnightCheck = now

  -- If the day changed while the skin stayed loaded, switch to today's base quote
  local today = os.date("%Y-%m-%d")
  local storedDay = tostring(SKIN:GetVariable("DayStamp") or "")

  if storedDay ~= today then
    local base = ensureDailyBaseIndex()
    persist("CurrentIndex", base)
    applyQuote(base)
  end

  return 0
end
`.trim();


const STORAGE_KEY = "rm_quote_package_v1";

const colourInput = document.getElementById("fontColour");
const colourHex = document.getElementById("colourHex");
const quoteInput = document.getElementById("quote");
const byLineInput = document.getElementById("byLine");
const fontSelect = document.getElementById("fontName");
const maxWidthInput = document.getElementById("maxWidth");
const maxWidthValue = document.getElementById("maxWidthValue");

const previewQuote = document.getElementById("previewQuote");
const previewByline = document.getElementById("previewByline");
const previewRendered = document.getElementById("previewRendered");
const previewContent = document.getElementById("previewContent");
const quoteAlignSelect = document.getElementById("quoteAlignmentSelect");
const byLineAlignSelect = document.getElementById("byLineAlignmentSelect");
const darkToggle = document.getElementById("previewDarkMode");

const form = document.querySelector("form");
const packageTbody = document.getElementById("packageTbody");
const downloadLuaBtn = document.getElementById("downloadLuaBtn");
const clearPackageBtn = document.getElementById("clearPackage");
const uploadPackageBtn = document.getElementById("uploadPackageBtn");
const uploadPackageInput = document.getElementById("uploadPackageInput");

// ---------- First-time setup modal ----------
const FIRST_TIME_KEY = "rmqs_first_time_modal_dismissed_v1";

(function showFirstTimeModal() {
  // Only show once per browser unless reset
  const dismissed = localStorage.getItem(FIRST_TIME_KEY) === "1";
  if (dismissed) return;

  const modalEl = document.getElementById("firstTimeModal");
  if (!modalEl || typeof bootstrap === "undefined") return;

  const modal = new bootstrap.Modal(modalEl, {
    backdrop: "static", // force a choice
    keyboard: false
  });

  // Show it immediately on first load
  modal.show();

  const dontShow = document.getElementById("dontShowAgain");
  const continueBtn = document.getElementById("firstTimeContinueBtn");

  function maybePersistDismissal() {
    // Default behaviour: if they don’t tick, it will show again next time
    if (dontShow && dontShow.checked) {
      localStorage.setItem(FIRST_TIME_KEY, "1");
    }
  }

  if (continueBtn) {
    continueBtn.addEventListener("click", maybePersistDismissal);
  }

  // Also persist if they close via the X button
  modalEl.addEventListener("hide.bs.modal", maybePersistDismissal);
})();


// ---------- Helpers ----------
function escapeHtml(s) {
    return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
}

function escapeLuaString(s) {
    return String(s)
        .replaceAll("\\", "\\\\")
        .replaceAll("\r\n", "\n")
        .replaceAll("\r", "\n")
        .replaceAll("\n", "\\n")
        .replaceAll('"', '\\"');
}

function hexToRgb(hex) {
    // expects #RRGGBB
    const h = (hex || "#000000").replace("#", "");
    const r = parseInt(h.slice(0, 2), 16);
    const g = parseInt(h.slice(2, 4), 16);
    const b = parseInt(h.slice(4, 6), 16);
    return { r, g, b };
}

function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
}

function normalizeForRainmeter(s) {
    return String(s)
        .replaceAll("’", "'")
        .replaceAll("‘", "'")
        .replaceAll("“", '"')
        .replaceAll("”", '"')
        .replaceAll("…", "...")
        .replaceAll("–", "-")
        .replaceAll("—", "-");
}

function getFontFamilyValue() {
    const val = (fontSelect && fontSelect.value) ? fontSelect.value : "";
    // If they chose "Custom font name…" (value=""), fall back to Segoe UI for now.
    // Later you can add a custom font input if you want.
    return val || "Segoe UI";
}

function getCurrentFormData() {
    const quote = (quoteInput.value || "").trim();
    const byline = (byLineInput.value || "").trim();
    const colour = (colourInput && colourInput.value) ? colourInput.value : "#000000";
    const fontFamily = getFontFamilyValue();

    return {
        quote,
        byline,
        fontFamily,
        colourHex: colour.toUpperCase(),
        quoteAlign: (quoteAlignSelect && quoteAlignSelect.value) ? quoteAlignSelect.value : "left",
        bylineAlign: (byLineAlignSelect && byLineAlignSelect.value) ? byLineAlignSelect.value : "right",
        createdAt: Date.now()
    };
}

// ---------- Package state ----------
function loadPackage() {
    try {
        return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
    } catch {
        return [];
    }
}

function savePackage(items) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
}

let packageItems = loadPackage();
let editIndex = null;
let luaFileHandle = null;

// ---------- Preview ----------
function updatePreview() {
    const data = getCurrentFormData();

    previewQuote.textContent = data.quote ? `"${data.quote}"` : "";
    previewByline.textContent = data.byline ? `— ${data.byline}` : "";

    previewQuote.style.whiteSpace = "pre-wrap";
    previewByline.style.whiteSpace = "pre-wrap";

    previewRendered.style.color = data.colourHex;
    previewRendered.style.fontFamily = data.fontFamily;

    previewQuote.style.textAlign = data.quoteAlign;
    previewByline.style.textAlign = data.bylineAlign;

    const dark = darkToggle && darkToggle.checked;
    previewRendered.style.backgroundColor = dark ? "#111" : "#fff";
    previewRendered.style.borderColor = dark ? "#444" : "#dee2e6";

    // Update max width based on character count
    if (previewContent && maxWidthInput) {
        const charWidth = 8; // approximate pixels per character
        previewContent.style.maxWidth = (maxWidthInput.value * charWidth) + 'px';
    }
}

// ---------- Table render ----------
function renderPackageTable() {
    if (!packageTbody) return;

    packageTbody.innerHTML = packageItems.map((item, idx) => {
        const fontPreview = `style="font-family:${escapeHtml(item.fontFamily)}"`;
        const colorSwatch = `<span class="badge" style="background:${item.colourHex}; border:1px solid rgba(0,0,0,0.2)">${item.colourHex}</span>`;

        return `
        <tr>
          <td>${escapeHtml(item.quote)}</td>
          <td>${escapeHtml(item.byline)}</td>
          <td ${fontPreview}>${escapeHtml(item.fontFamily)}</td>
          <td>${colorSwatch}</td>
          <td class="text-end text-nowrap">
  <button class="btn btn-sm btn-outline-secondary me-1" data-edit="${idx}">
    Edit
  </button>
  <button class="btn btn-sm btn-outline-danger" data-del="${idx}">
    Delete
  </button>
</td>
        </tr>
      `;
    }).join("");

    // Delete handlers
    packageTbody.querySelectorAll("[data-del]").forEach(btn => {
        btn.addEventListener("click", () => {
            const i = Number(btn.getAttribute("data-del"));
            packageItems.splice(i, 1);
            savePackage(packageItems);
            renderPackageTable();
        });
    });
    // Edit handlers
    packageTbody.querySelectorAll("[data-edit]").forEach(btn => {
        btn.addEventListener("click", () => {
            const i = Number(btn.getAttribute("data-edit"));
            loadItemIntoForm(i);
        });
    });
}

// ---------- Load item into form for editing ----------
function loadItemIntoForm(index) {
    const item = packageItems[index];
    if (!item) return;

    editIndex = index;

    // Populate form fields
    quoteInput.value = item.quote;
    byLineInput.value = item.byline;
    fontSelect.value = item.fontFamily || "Segoe UI";
    colourInput.value = item.colourHex || "#ffffff";
    quoteAlignSelect.value = item.quoteAlign || "left";
    byLineAlignSelect.value = item.bylineAlign || "right";

    // Update UI bits
    if (colourHex) colourHex.textContent = `Hex: ${item.colourHex}`;
    document.getElementById("submitQuoteBtn").textContent = "Save Changes";

    updatePreview();
}


// ---------- Lua export ----------
function generateQuotesLua(items) {
    const lines = [];

    lines.push(LUA_HEADER);
    lines.push("");
    lines.push("quotes = {");

    for (const it of items) {
        const rgb = hexToRgb(it.colourHex);
        lines.push(
            `  { text="${escapeLuaString(normalizeForRainmeter(it.quote))}", by="${escapeLuaString(normalizeForRainmeter(it.byline))}", font="${escapeLuaString(it.fontFamily)}", color={${rgb.r},${rgb.g},${rgb.b}}, align="${escapeLuaString(it.quoteAlign)}", byAlign="${escapeLuaString(it.bylineAlign)}" },`
        );
    }

    lines.push("}");
    lines.push("");
    lines.push(LUA_RUNTIME_TEMPLATE);

    return lines.join("\n");
}


// ---------- Wire up ----------
if (form) {
    form.addEventListener("submit", (e) => {
        e.preventDefault();

        const data = getCurrentFormData();
        if (!data.quote) return;

        if (editIndex === null) {
            // ADD NEW
            packageItems.push(data);
        } else {
            // EDIT EXISTING
            packageItems[editIndex] = data;
            editIndex = null;
            document.getElementById("submitQuoteBtn").textContent = "Add to Package";
        }

        savePackage(packageItems);
        renderPackageTable();

        // Clear quote fields after save
        quoteInput.value = "";
        byLineInput.value = "";
        updatePreview();
    });
}


if (downloadLuaBtn) {
  downloadLuaBtn.addEventListener("click", (e) => {
    e.preventDefault();

    if (!packageItems.length) {
      alert("No quotes yet. Add at least one quote first.");
      return;
    }

    const lua = generateQuotesLua(packageItems);
    downloadText("quotes.lua", lua);
  });
}




if (clearPackageBtn) {
    clearPackageBtn.addEventListener("click", () => {
        packageItems = [];
        editIndex = null;
        savePackage(packageItems);
        renderPackageTable();
        document.getElementById("submitQuoteBtn").textContent = "Add to Package";
    });
}

// Live preview listeners
if (quoteInput) quoteInput.addEventListener("input", updatePreview);
if (byLineInput) byLineInput.addEventListener("input", updatePreview);
if (fontSelect) fontSelect.addEventListener("change", updatePreview);
if (quoteAlignSelect) quoteAlignSelect.addEventListener("change", updatePreview);
if (byLineAlignSelect) byLineAlignSelect.addEventListener("change", updatePreview);
if (darkToggle) darkToggle.addEventListener("change", updatePreview);
if (colourInput) {
    colourInput.addEventListener("input", () => {
        if (colourHex) colourHex.textContent = `Hex: ${colourInput.value.toUpperCase()}`;
        updatePreview();
    });
}
if (maxWidthInput) maxWidthInput.addEventListener("input", () => {
    if (maxWidthValue) maxWidthValue.textContent = maxWidthInput.value;
    updatePreview();
});

// Wire upload button to hidden file input
function rgbToHex(r, g, b) {
    const toHex = (n) => n.toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
}

function tryParseLuaQuotes(luaText) {
    // Very small parser: find table entries inside quotes = { ... }
    const entries = [];
    const blockRegex = /\{([\s\S]*?)\},?/g;
    let m;
    while ((m = blockRegex.exec(luaText)) !== null) {
        const block = m[1];
        const getString = (key) => {
            const re = new RegExp(key + '\\s*=\\s*"([\\s\\S]*?)"', 'i');
            const mm = block.match(re);
            if (!mm) return '';
            return mm[1].replace(/\\\\n/g, '\n').replace(/\\\\"/g, '"').replace(/\\\\\\\\/g, '\\');
        };
        const text = getString('text');
        const by = getString('by');
        const font = getString('font') || 'Segoe UI';
        const alignMatch = block.match(/align\\s*=\\s*"(.*?)"/i);
        const byAlignMatch = block.match(/byAlign\\s*=\\s*"(.*?)"/i);
        const colorMatch = block.match(/color\s*=\s*\{\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\}/i);
        const rgb = colorMatch ? { r: Number(colorMatch[1]), g: Number(colorMatch[2]), b: Number(colorMatch[3]) } : { r: 0, g: 0, b: 0 };
        const colourHex = rgbToHex(rgb.r, rgb.g, rgb.b);

        // require at least text
        if (text) {
            entries.push({
                quote: text,
                byline: by,
                fontFamily: font,
                colourHex,
                quoteAlign: (alignMatch && alignMatch[1]) ? alignMatch[1] : 'left',
                bylineAlign: (byAlignMatch && byAlignMatch[1]) ? byAlignMatch[1] : 'right',
                createdAt: Date.now()
            });
        }
    }
    return entries;
}

function importPackageFromJson(text) {
    const parsed = JSON.parse(text);
    if (!Array.isArray(parsed)) throw new Error('JSON must be an array of package items');
    // Map/validate entries
    return parsed.map(it => ({
        quote: String(it.quote || it.text || '').trim(),
        byline: String(it.byline || it.by || '').trim(),
        fontFamily: String(it.fontFamily || it.font || 'Segoe UI'),
        colourHex: String(it.colourHex || it.color || '#000000').toUpperCase(),
        quoteAlign: String(it.quoteAlign || it.align || 'left'),
        bylineAlign: String(it.bylineAlign || it.byAlign || 'right'),
        createdAt: it.createdAt || Date.now()
    }));
}

if (uploadPackageBtn && uploadPackageInput) {
    uploadPackageBtn.addEventListener('click', () => uploadPackageInput.click());
    uploadPackageInput.addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const name = f.name || '';
        const reader = new FileReader();
        reader.onerror = () => alert('Failed to read file');
        reader.onload = () => {
            const txt = String(reader.result || "");
            try {
                const imported = tryParseLuaQuotes(txt);

                if (!imported || imported.length === 0) {
                alert("No valid quotes were found in that Lua file.");
                return;
                }

                packageItems = imported; // replace, not merge (better UX for 'upload then edit')
                savePackage(packageItems);
                renderPackageTable();
                alert(`Loaded ${imported.length} quote(s) from quotes.lua`);
            } catch (err) {
                console.error(err);
                alert("Failed to import quotes.lua: " + err.message);
            }
            };

        reader.readAsText(f);
        // clear selection so same file can be re-selected later
        uploadPackageInput.value = '';
    });
}

// Initial UI sync
if (colourHex && colourInput) colourHex.textContent = `Hex: ${colourInput.value.toUpperCase()}`;
if (maxWidthValue && maxWidthInput) maxWidthValue.textContent = maxWidthInput.value;
updatePreview();
renderPackageTable();