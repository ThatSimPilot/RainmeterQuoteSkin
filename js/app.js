"use strict";

const STORAGE_KEY = "rm_quote_package_v1";

const INI_CONTENT = `[Rainmeter]
Update=1000
AccurateText=1
DynamicWindowSize=1
OnRefreshAction=[!CommandMeasure MeasureQuotes "GetQuote()"]

[Variables]
; Layout
QuoteX=20
QuoteY=20
QuoteW=520
Gap=12

; Defaults (used if a quote entry doesn't specify)
DefaultFont=Segoe UI
DefaultSize=18
DefaultColor=255,255,255

; Variables populated by Lua
QuoteText=Loading...
QuoteAuthor=
QuoteFont=#DefaultFont#
QuoteSize=#DefaultSize#
QuoteColor=#DefaultColor#
QuoteAlign=LeftTop
QuoteByAlign=LeftTop
QuoteXPos=#QuoteX#
ByXPos=#QuoteX#

[MeasureQuotes]
Measure=Script
ScriptFile=#@#Scripts\\quotes.lua

[MeterQuote]
Meter=String
X=#QuoteXPos#
Y=#QuoteY#
W=#QuoteW#
Text=#QuoteText#
FontFace=#QuoteFont#
FontSize=#QuoteSize#
FontColor=#QuoteColor#
StringAlign=#QuoteAlign#
AntiAlias=1
ClipString=2
DynamicVariables=1

[MeterAuthor]
Meter=String
X=#ByXPos#
Y=([MeterQuote:Y] + [MeterQuote:MeterHeight] + #Gap#)
Text=- #QuoteAuthor#
FontFace=#QuoteFont#
FontSize=14
FontColor=#QuoteColor#
StringAlign=#QuoteByAlign#
AntiAlias=1
DynamicVariables=1
`;

const README_CONTENT = `# Rainmeter Quote Skin

This is a Rainmeter skin that displays inspirational quotes. The quotes are stored in \`quotes.lua\` and updated daily.

## Installation

1. Copy the folder 'RainmeterQuoteSkin' to your Rainmeter Skins folder or create a folder and copy \`quotes.ini\` and \`quotes.lua\` to this.
2. Load the skin in Rainmeter.

## Customization

Visit https://thatsimpilot.github.io/RainmeterQuoteSkin/ and upload quotes.lua file to modify existing or add new quotes to the package.

Alternatively, for ADVANCED USERS ONLY: Manually edit \`quotes.lua\` to add or modify quotes. Each quote has text, author, font, color, and alignment options.

## Generated by

Rainmeter Quote Skin Generator
©ThatSimPilot (Hayden H)`;

const colourInput = document.getElementById("fontColour");
const colourHex = document.getElementById("colourHex");
const quoteInput = document.getElementById("quote");
const byLineInput = document.getElementById("byLine");
const fontSelect = document.getElementById("fontName");
const maxWidthInput = document.getElementById("maxWidth");
const maxWidthValue = document.getElementById("maxWidthValue");

const previewQuote = document.getElementById("previewQuote");
const previewByline = document.getElementById("previewByline");
const previewRendered = document.getElementById("previewRendered");
const previewContent = document.getElementById("previewContent");
const quoteAlignSelect = document.getElementById("quoteAlignmentSelect");
const byLineAlignSelect = document.getElementById("byLineAlignmentSelect");
const darkToggle = document.getElementById("previewDarkMode");

const form = document.querySelector("form");
const packageTbody = document.getElementById("packageTbody");
const downloadLuaBtn = document.getElementById("downloadLua");
const clearPackageBtn = document.getElementById("clearPackage");
const uploadPackageBtn = document.getElementById("uploadPackageBtn");
const uploadPackageInput = document.getElementById("uploadPackageInput");

// ---------- Helpers ----------
function escapeHtml(s) {
    return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
}

function escapeLuaString(s) {
    return String(s)
        .replaceAll("\\", "\\\\")
        .replaceAll("\r\n", "\n")
        .replaceAll("\r", "\n")
        .replaceAll("\n", "\\n")
        .replaceAll('"', '\\"');
}

function hexToRgb(hex) {
    // expects #RRGGBB
    const h = (hex || "#000000").replace("#", "");
    const r = parseInt(h.slice(0, 2), 16);
    const g = parseInt(h.slice(2, 4), 16);
    const b = parseInt(h.slice(4, 6), 16);
    return { r, g, b };
}

function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
}

function normalizeForRainmeter(s) {
    return String(s)
        .replaceAll("’", "'")
        .replaceAll("‘", "'")
        .replaceAll("“", '"')
        .replaceAll("”", '"')
        .replaceAll("…", "...")
        .replaceAll("–", "-")
        .replaceAll("—", "-");
}

function getFontFamilyValue() {
    const val = (fontSelect && fontSelect.value) ? fontSelect.value : "";
    // If they chose "Custom font name…" (value=""), fall back to Segoe UI for now.
    // Later you can add a custom font input if you want.
    return val || "Segoe UI";
}

function getCurrentFormData() {
    const quote = (quoteInput.value || "").trim();
    const byline = (byLineInput.value || "").trim();
    const colour = (colourInput && colourInput.value) ? colourInput.value : "#000000";
    const fontFamily = getFontFamilyValue();

    return {
        quote,
        byline,
        fontFamily,
        colourHex: colour.toUpperCase(),
        quoteAlign: (quoteAlignSelect && quoteAlignSelect.value) ? quoteAlignSelect.value : "left",
        bylineAlign: (byLineAlignSelect && byLineAlignSelect.value) ? byLineAlignSelect.value : "right",
        createdAt: Date.now()
    };
}

// ---------- Package state ----------
function loadPackage() {
    try {
        return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
    } catch {
        return [];
    }
}

function savePackage(items) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
}

let packageItems = loadPackage();
let editIndex = null;
let luaFileHandle = null;

// ---------- Preview ----------
function updatePreview() {
    const data = getCurrentFormData();

    previewQuote.textContent = data.quote ? `"${data.quote}"` : "";
    previewByline.textContent = data.byline ? `— ${data.byline}` : "";

    previewQuote.style.whiteSpace = "pre-wrap";
    previewByline.style.whiteSpace = "pre-wrap";

    previewRendered.style.color = data.colourHex;
    previewRendered.style.fontFamily = data.fontFamily;

    previewQuote.style.textAlign = data.quoteAlign;
    previewByline.style.textAlign = data.bylineAlign;

    const dark = darkToggle && darkToggle.checked;
    previewRendered.style.backgroundColor = dark ? "#111" : "#fff";
    previewRendered.style.borderColor = dark ? "#444" : "#dee2e6";

    // Update max width based on character count
    if (previewContent && maxWidthInput) {
        const charWidth = 8; // approximate pixels per character
        previewContent.style.maxWidth = (maxWidthInput.value * charWidth) + 'px';
    }
}

// ---------- Table render ----------
function renderPackageTable() {
    if (!packageTbody) return;

    packageTbody.innerHTML = packageItems.map((item, idx) => {
        const fontPreview = `style="font-family:${escapeHtml(item.fontFamily)}"`;
        const colorSwatch = `<span class="badge" style="background:${item.colourHex}; border:1px solid rgba(0,0,0,0.2)">${item.colourHex}</span>`;

        return `
        <tr>
          <td>${escapeHtml(item.quote)}</td>
          <td>${escapeHtml(item.byline)}</td>
          <td ${fontPreview}>${escapeHtml(item.fontFamily)}</td>
          <td>${colorSwatch}</td>
          <td class="text-end text-nowrap">
  <button class="btn btn-sm btn-outline-secondary me-1" data-edit="${idx}">
    Edit
  </button>
  <button class="btn btn-sm btn-outline-danger" data-del="${idx}">
    Delete
  </button>
</td>
        </tr>
      `;
    }).join("");

    // Delete handlers
    packageTbody.querySelectorAll("[data-del]").forEach(btn => {
        btn.addEventListener("click", () => {
            const i = Number(btn.getAttribute("data-del"));
            packageItems.splice(i, 1);
            savePackage(packageItems);
            renderPackageTable();
        });
    });
    // Edit handlers
    packageTbody.querySelectorAll("[data-edit]").forEach(btn => {
        btn.addEventListener("click", () => {
            const i = Number(btn.getAttribute("data-edit"));
            loadItemIntoForm(i);
        });
    });
}

// ---------- Load item into form for editing ----------
function loadItemIntoForm(index) {
    const item = packageItems[index];
    if (!item) return;

    editIndex = index;

    // Populate form fields
    quoteInput.value = item.quote;
    byLineInput.value = item.byline;
    fontSelect.value = item.fontFamily || "Segoe UI";
    colourInput.value = item.colourHex || "#ffffff";
    quoteAlignSelect.value = item.quoteAlign || "left";
    byLineAlignSelect.value = item.bylineAlign || "right";

    // Update UI bits
    if (colourHex) colourHex.textContent = `Hex: ${item.colourHex}`;
    document.getElementById("submitQuoteBtn").textContent = "Save Changes";

    updatePreview();
}


// ---------- Lua export ----------
function generateQuotesLua(items) {
    console.log("generateQuotesLua called with", items.length, "items");

    const lines = [];
    lines.push("-- quotes.lua");
    lines.push("-- Auto-generated by Rainmeter Quote Skin Generator");
    lines.push("-- Expected by your quotes.ini:");
    lines.push("--   [MeasureQuotes]");
    lines.push("--   Measure=Script");
    lines.push("--   ScriptFile=#@#Scripts\\quotes.lua");
    lines.push("");

    lines.push("quotes = {");
    for (const it of items) {
        const rgb = hexToRgb(it.colourHex);
        lines.push(
            `  { text="${escapeLuaString(normalizeForRainmeter(it.quote))}", by="${escapeLuaString(normalizeForRainmeter(it.byline))}", font="${escapeLuaString(it.fontFamily)}", color={${rgb.r},${rgb.g},${rgb.b}}, align="${escapeLuaString(it.quoteAlign)}", byAlign="${escapeLuaString(it.bylineAlign)}" },`
        );
    }
    lines.push("}");
    lines.push("");

    lines.push(`
                local function safeNumber(v, fallback)
                local n = tonumber(v)
                if n == nil then return fallback end
                return n
                end

                local function safeColor(c)
                if type(c) == "table" then
                    local r = math.floor(safeNumber(c[1], 255))
                    local g = math.floor(safeNumber(c[2], 255))
                    local b = math.floor(safeNumber(c[3], 255))
                    if r < 0 then r = 0 elseif r > 255 then r = 255 end
                    if g < 0 then g = 0 elseif g > 255 then g = 0 elseif g > 255 then g = 255 end
                    if b < 0 then b = 0 elseif b > 255 then b = 255 end
                    return r, g, b
                end
                return 255, 255, 255
                end

                local function toTopAlign(a, default)
                a = (a or default or "left"):lower()
                if a == "center" then return "CenterTop" end
                if a == "right" then return "RightTop" end
                -- Rainmeter doesn't really support "justify" as a StringAlign mode.
                -- We'll keep it as LeftTop so it renders consistently.
                return "LeftTop"
                end

                local function computeXPos(alignTop, baseX, width)
                if alignTop == "CenterTop" then return baseX + (width / 2) end
                if alignTop == "RightTop" then return baseX + width end
                return baseX
                end

                local function chooseQuoteIndex()
                local n = #quotes
                if n <= 0 then return nil end

                -- Day-of-year rotation
                local day = tonumber(os.date("%j")) or 1
                local idx = (day % n) + 1
                return idx
                end

                function Initialize()
                -- You can call GetQuote() here too, but OnRefreshAction already does it.
                end

                function GetQuote()
                local baseX = safeNumber(SKIN:GetVariable("QuoteX"), 20)
                local width = safeNumber(SKIN:GetVariable("QuoteW"), 520)

                if type(quotes) ~= "table" or #quotes == 0 then
                    SKIN:Bang("!SetVariable", "QuoteText", "No quotes found.")
                    SKIN:Bang("!SetVariable", "QuoteAuthor", "")
                    SKIN:Bang("!SetVariable", "QuoteFont", SKIN:GetVariable("DefaultFont") or "Segoe UI")
                    SKIN:Bang("!SetVariable", "QuoteSize", SKIN:GetVariable("DefaultSize") or "28")
                    SKIN:Bang("!SetVariable", "QuoteColor", SKIN:GetVariable("DefaultColor") or "255,255,255")
                    SKIN:Bang("!SetVariable", "QuoteAlign", "LeftTop")
                    SKIN:Bang("!SetVariable", "QuoteByAlign", "LeftTop")
                    SKIN:Bang("!SetVariable", "QuoteXPos", tostring(baseX))
                    SKIN:Bang("!SetVariable", "ByXPos", tostring(baseX))
                else
                    local idx = chooseQuoteIndex()
                    local q = quotes[idx] or quotes[1]

                    local text = q.text or ""
                    local by = q.by or ""
                    local font = q.font or (SKIN:GetVariable("DefaultFont") or "Segoe UI")
                    local r, g, b = safeColor(q.color)

                    local quoteAlignTop = toTopAlign(q.align, "left")
                    local byAlignTop = toTopAlign(q.byAlign, "left")

                    local quoteXPos = computeXPos(quoteAlignTop, baseX, width)
                    local byXPos = computeXPos(byAlignTop, baseX, width)

                    SKIN:Bang("!SetVariable", "QuoteText", text)
                    SKIN:Bang("!SetVariable", "QuoteAuthor", by)
                    SKIN:Bang("!SetVariable", "QuoteFont", font)
                    SKIN:Bang("!SetVariable", "QuoteSize", SKIN:GetVariable("DefaultSize") or "28")
                    SKIN:Bang("!SetVariable", "QuoteColor", string.format("%d,%d,%d", r, g, b))
                    SKIN:Bang("!SetVariable", "QuoteAlign", quoteAlignTop)
                    SKIN:Bang("!SetVariable", "QuoteByAlign", byAlignTop)
                    SKIN:Bang("!SetVariable", "QuoteXPos", tostring(quoteXPos))
                    SKIN:Bang("!SetVariable", "ByXPos", tostring(byXPos))
                end

                -- Force meters to refresh after variable changes
                SKIN:Bang("!UpdateMeter", "MeterQuote")
                SKIN:Bang("!UpdateMeter", "MeterAuthor")
                SKIN:Bang("!Redraw")
                end

                function Update()
                return 0
                end
                `.trim());

    // ✅ IMPORTANT: return the final Lua file text
    return lines.join("\n");
}


// ---------- Wire up ----------
if (form) {
    form.addEventListener("submit", (e) => {
        e.preventDefault();

        const data = getCurrentFormData();
        if (!data.quote) return;

        if (editIndex === null) {
            // ADD NEW
            packageItems.push(data);
        } else {
            // EDIT EXISTING
            packageItems[editIndex] = data;
            editIndex = null;
            document.getElementById("submitQuoteBtn").textContent = "Add to Package";
        }

        savePackage(packageItems);
        renderPackageTable();

        // Clear quote fields after save
        quoteInput.value = "";
        byLineInput.value = "";
        updatePreview();
    });
}

const downloadPackageBtn = document.getElementById("downloadPackageBtn");

if (downloadLuaBtn) {
    downloadLuaBtn.addEventListener("click", (e) => {
        e.preventDefault(); // stops the # jump

        if (!packageItems.length) {
            alert("No quotes in the package yet.");
            return;
        }

        const lua = generateQuotesLua(packageItems);
        downloadText("quotes.lua", lua);
    });
}

const downloadIniBtn = document.getElementById("downloadIni");
if (downloadIniBtn) {
    downloadIniBtn.addEventListener("click", (e) => {
        e.preventDefault();
        downloadText("quotes.ini", INI_CONTENT);
    });
}

if (downloadPackageBtn) {
    downloadPackageBtn.addEventListener("click", async (e) => {
        e.preventDefault();
        console.log("Download Package clicked");

        if (!packageItems.length) {
            alert("No quotes in the package yet.");
            return;
        }

        try {
            if (typeof JSZip === 'undefined') {
                throw new Error("JSZip library not loaded. Please check your internet connection.");
            }
            // Update the lua file first
            if (luaFileHandle) {
                await updateLuaFile(packageItems);
            }

            // Generate ZIP
            const zip = new JSZip();
            const lua = generateQuotesLua(packageItems);

            const root = zip.folder("RainmeterQuoteSkin");

            root.file("quotes.ini", INI_CONTENT);

            root
                .folder("@Resources")
                .folder("Scripts")
                .file("quotes.lua", lua);

            root.file("README.txt", README_CONTENT);

            console.log("Lua length:", lua?.length, "first 100:", lua?.slice(0, 100));
            const zipBlob = await zip.generateAsync({
                type: "blob",
                compression: "DEFLATE",
                compressionOptions: { level: 6 }
            });
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "RainmeterQuoteSkin.zip";
            a.click();
            URL.revokeObjectURL(url);

            // Show modal with instructions
            const modal = new bootstrap.Modal(document.getElementById('downloadModal'));
            modal.show();
        } catch (error) {
            console.error("Error generating ZIP:", error);
            alert("Error generating package: " + error.message);
        }
    });
}



if (clearPackageBtn) {
    clearPackageBtn.addEventListener("click", () => {
        packageItems = [];
        editIndex = null;
        savePackage(packageItems);
        renderPackageTable();
        document.getElementById("submitQuoteBtn").textContent = "Add to Package";
    });
}

// Live preview listeners
if (quoteInput) quoteInput.addEventListener("input", updatePreview);
if (byLineInput) byLineInput.addEventListener("input", updatePreview);
if (fontSelect) fontSelect.addEventListener("change", updatePreview);
if (quoteAlignSelect) quoteAlignSelect.addEventListener("change", updatePreview);
if (byLineAlignSelect) byLineAlignSelect.addEventListener("change", updatePreview);
if (darkToggle) darkToggle.addEventListener("change", updatePreview);
if (colourInput) {
    colourInput.addEventListener("input", () => {
        if (colourHex) colourHex.textContent = `Hex: ${colourInput.value.toUpperCase()}`;
        updatePreview();
    });
}
if (maxWidthInput) maxWidthInput.addEventListener("input", () => {
    if (maxWidthValue) maxWidthValue.textContent = maxWidthInput.value;
    updatePreview();
});

// Wire upload button to hidden file input
function rgbToHex(r, g, b) {
    const toHex = (n) => n.toString(16).padStart(2, '0');
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
}

function tryParseLuaQuotes(luaText) {
    // Very small parser: find table entries inside quotes = { ... }
    const entries = [];
    const blockRegex = /\{([\s\S]*?)\},?/g;
    let m;
    while ((m = blockRegex.exec(luaText)) !== null) {
        const block = m[1];
        const getString = (key) => {
            const re = new RegExp(key + '\\s*=\\s*"([\\s\\S]*?)"', 'i');
            const mm = block.match(re);
            if (!mm) return '';
            return mm[1].replace(/\\\\n/g, '\n').replace(/\\\\"/g, '"').replace(/\\\\\\\\/g, '\\');
        };
        const text = getString('text');
        const by = getString('by');
        const font = getString('font') || 'Segoe UI';
        const alignMatch = block.match(/align\\s*=\\s*"(.*?)"/i);
        const byAlignMatch = block.match(/byAlign\\s*=\\s*"(.*?)"/i);
        const colorMatch = block.match(/color\s*=\s*\{\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\}/i);
        const rgb = colorMatch ? { r: Number(colorMatch[1]), g: Number(colorMatch[2]), b: Number(colorMatch[3]) } : { r: 0, g: 0, b: 0 };
        const colourHex = rgbToHex(rgb.r, rgb.g, rgb.b);

        // require at least text
        if (text) {
            entries.push({
                quote: text,
                byline: by,
                fontFamily: font,
                colourHex,
                quoteAlign: (alignMatch && alignMatch[1]) ? alignMatch[1] : 'left',
                bylineAlign: (byAlignMatch && byAlignMatch[1]) ? byAlignMatch[1] : 'right',
                createdAt: Date.now()
            });
        }
    }
    return entries;
}

function importPackageFromJson(text) {
    const parsed = JSON.parse(text);
    if (!Array.isArray(parsed)) throw new Error('JSON must be an array of package items');
    // Map/validate entries
    return parsed.map(it => ({
        quote: String(it.quote || it.text || '').trim(),
        byline: String(it.byline || it.by || '').trim(),
        fontFamily: String(it.fontFamily || it.font || 'Segoe UI'),
        colourHex: String(it.colourHex || it.color || '#000000').toUpperCase(),
        quoteAlign: String(it.quoteAlign || it.align || 'left'),
        bylineAlign: String(it.bylineAlign || it.byAlign || 'right'),
        createdAt: it.createdAt || Date.now()
    }));
}

if (uploadPackageBtn && uploadPackageInput) {
    uploadPackageBtn.addEventListener('click', () => uploadPackageInput.click());
    uploadPackageInput.addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const name = f.name || '';
        const reader = new FileReader();
        reader.onerror = () => alert('Failed to read file');
        reader.onload = () => {
            const txt = String(reader.result || '');
            try {
                let imported = [];
                if (/\.json$/i.test(name)) {
                    imported = importPackageFromJson(txt);
                } else if (/\.lua$/i.test(name)) {
                    imported = tryParseLuaQuotes(txt);
                } else if (/\.zip$/i.test(name)) {
                    alert('ZIP import not supported yet.');
                    return;
                } else {
                    // try JSON first, then Lua
                    try { imported = importPackageFromJson(txt); }
                    catch (e) { imported = tryParseLuaQuotes(txt); }
                }

                if (!imported || imported.length === 0) {
                    alert('No valid entries were found in the selected file.');
                    return;
                }

                // Merge into existing packageItems
                packageItems = packageItems.concat(imported);
                savePackage(packageItems);
                renderPackageTable();
                alert(`Imported ${imported.length} item(s).`);
            } catch (err) {
                console.error(err);
                alert('Failed to import package: ' + err.message);
            }
        };
        reader.readAsText(f);
        // clear selection so same file can be re-selected later
        uploadPackageInput.value = '';
    });
}

// Initial UI sync
if (colourHex && colourInput) colourHex.textContent = `Hex: ${colourInput.value.toUpperCase()}`;
if (maxWidthValue && maxWidthInput) maxWidthValue.textContent = maxWidthInput.value;
updatePreview();
renderPackageTable();